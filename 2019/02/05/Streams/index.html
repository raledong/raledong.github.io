<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言Stream是Java 8中的一个重大新功能。这个深入的教程是流支持的许多功能的介绍，并着重于简单实用的示例。 了解这个之前，你需要有对Java 8有基础的实践性的知识(lambda表达式，方法引用) ##介绍##首先，不应该将Java 8 Streams与Java I&#x2F;O流混淆（例如：FileInputStream等）;它们彼此之间关联不大。 简而言之，流是对数据源的包装，使我们能">
<meta property="og:type" content="article">
<meta property="og:title" content="猫头鹰的深夜翻译：Java Streams">
<meta property="og:url" content="http://yoursite.com/2019/02/05/Streams/index.html">
<meta property="og:site_name" content="眯眯眼猫头鹰的小树杈">
<meta property="og:description" content="前言Stream是Java 8中的一个重大新功能。这个深入的教程是流支持的许多功能的介绍，并着重于简单实用的示例。 了解这个之前，你需要有对Java 8有基础的实践性的知识(lambda表达式，方法引用) ##介绍##首先，不应该将Java 8 Streams与Java I&#x2F;O流混淆（例如：FileInputStream等）;它们彼此之间关联不大。 简而言之，流是对数据源的包装，使我们能">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-02-05T14:55:56.000Z">
<meta property="article:modified_time" content="2024-08-18T07:04:37.369Z">
<meta property="article:author" content="Rale Dong">
<meta property="article:tag" content="翻译">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/2019/02/05/Streams/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2019/02/05/Streams/","path":"2019/02/05/Streams/","title":"猫头鹰的深夜翻译：Java Streams"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>猫头鹰的深夜翻译：Java Streams | 眯眯眼猫头鹰的小树杈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">眯眯眼猫头鹰的小树杈</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Owned By Deer&Owl</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAStream"><span class="nav-number">2.</span> <span class="nav-text">创建Stream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">流操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%AE%A1%E9%81%93"><span class="nav-number">4.</span> <span class="nav-text">方法类型和管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E8%AE%A1%E7%AE%97"><span class="nav-number">5.</span> <span class="nav-text">惰性计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="nav-number">6.</span> <span class="nav-text">基于比较的流操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allMatch-anyMatch%E5%92%8CnoneMatch"><span class="nav-number">7.</span> <span class="nav-text">allMatch, anyMatch和noneMatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">特定类型的流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">8.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C"><span class="nav-number">8.2.</span> <span class="nav-text">特殊操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reduction%E6%93%8D%E4%BD%9C"><span class="nav-number">9.</span> <span class="nav-text">Reduction操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7collect"><span class="nav-number">10.</span> <span class="nav-text">高级collect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toCollection"><span class="nav-number">11.</span> <span class="nav-text">toCollection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summarizingDouble"><span class="nav-number">12.</span> <span class="nav-text">summarizingDouble</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#partitioningBy"><span class="nav-number">13.</span> <span class="nav-text">partitioningBy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#groupingBy"><span class="nav-number">14.</span> <span class="nav-text">groupingBy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallel-Streams"><span class="nav-number">15.</span> <span class="nav-text">Parallel Streams</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Infinite-Streams"><span class="nav-number">16.</span> <span class="nav-text">Infinite Streams</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rale Dong</p>
  <div class="site-description" itemprop="description">总是打盹，时而清醒</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">289</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">76</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/05/Streams/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rale Dong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="眯眯眼猫头鹰的小树杈">
      <meta itemprop="description" content="总是打盹，时而清醒">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="猫头鹰的深夜翻译：Java Streams | 眯眯眼猫头鹰的小树杈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          猫头鹰的深夜翻译：Java Streams
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-05 22:55:56" itemprop="dateCreated datePublished" datetime="2019-02-05T22:55:56+08:00">2019-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 15:04:37" itemprop="dateModified" datetime="2024-08-18T15:04:37+08:00">2024-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8C%AB%E5%A4%B4%E9%B9%B0%E7%9A%84%E6%B7%B1%E5%A4%9C%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">猫头鹰的深夜翻译</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Stream是Java 8中的一个重大新功能。这个深入的教程是流支持的许多功能的介绍，并着重于简单实用的示例。</p>
<p>了解这个之前，你需要有对Java 8有基础的实践性的知识(lambda表达式，方法引用)</p>
<p>##介绍##<br>首先，不应该将Java 8 Streams与Java I&#x2F;O流混淆（例如：FileInputStream等）;它们彼此之间关联不大。</p>
<p>简而言之，流是对数据源的包装，使我们能够使用该数据源并对其快速便捷的批量处理。</p>
<p><strong>流不存储数据，从这个意义上说，它不是一个数据结构。它也从不修改底层数据源。</strong></p>
<p><code>java.util.stream</code>提供的新功能支持对元素的流进行函数式编程风格的操作，比如在集合上进行map-reduce转换。</p>
<p>现在让我们在讨论术语和核心概念之前，深入一些简单的流创建和使用示例。</p>
<span id="more"></span>

<h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>我们首先从现有数组中获取流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Employee[] arrayOfEmps = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;Jeff Bezos&quot;</span>, <span class="number">100000.0</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;Bill Gates&quot;</span>, <span class="number">200000.0</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;Mark Zuckerberg&quot;</span>, <span class="number">300000.0</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Stream.of(arrayOfEmps);</span><br></pre></td></tr></table></figure>

<p>我们也能从现有的列表中获取流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Employee&gt; empList = Arrays.asList(arrayOfEmps);</span><br><span class="line">empList.stream();</span><br></pre></td></tr></table></figure>
<p>请注意，Java 8在Collection接口添加了一个新的<code>stream()</code>方法。</p>
<p>我们也可以在独立对象上使用<code>Stream.of()</code>创建流:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(arrayOfEmps[<span class="number">0</span>], arrayOfEmps[<span class="number">1</span>], arrayOfEmps[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>或者直接使用<code>Stream.builder()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.Builder&lt;Employee&gt; empStreamBuilder = Stream.builder();</span><br><span class="line">empStreamBuilder.accept(arrayOfEmps[<span class="number">0</span>]);</span><br><span class="line">empStreamBuilder.accept(arrayOfEmps[<span class="number">1</span>]);</span><br><span class="line">empStreamBuilder.accept(arrayOfEmps[<span class="number">2</span>]);</span><br><span class="line">Stream&lt;Employee&gt; empStream = empStreamBuilder.build();</span><br></pre></td></tr></table></figure>
<p>还有其他方法可以获得流，其中的一些方法我们将在下面的部分中看到。</p>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><p>现在让我们看看我们可以在语言中使用新流支持的帮助下执行的一些常见用法和操作。</p>
<p><code>forEach()</code>是最简单也是最常用的操作。它遍历流元素，并在每个元素上调用提供的函数。</p>
<p>这个方法非常常见，它直接在<code>Iterable</code>，<code>Map</code>等中引入了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenIncrementSalaryForEachEmployee_thenApplyNewSalary</span><span class="params">()</span> &#123;    </span><br><span class="line">    empList.stream().forEach(e -&gt; e.salaryIncrement(<span class="number">10.0</span>));</span><br><span class="line">    assertThat(empList, contains(</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">110000.0</span>)),</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">220000.0</span>)),</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">330000.0</span>))</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将有效地调用empList中每个元素的salaryIncrement()方法。</p>
<p><code>forEach()</code>是一个终结操作。在执行该操作后，流管道将被视为已经被使用，将无法再被使用。我们会在下一节继续讨论终结操作。</p>
<p><code>map()</code>在对原始流执行完函数后会创建一个新的流。新的流将会是另一种类型。</p>
<p>以下示例将整数流转换为Employee流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenMapIdToEmployees_thenGetEmployeeStream</span><span class="params">()</span> &#123;</span><br><span class="line">    Integer[] empIds = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    List&lt;Employee&gt; employees = Stream.of(empIds)</span><br><span class="line">      .map(employeeRepository::findById)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">    assertEquals(employees.size(), empIds.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先从一个数组中获得员工Id流。每个Id被传入<code>employeeRepository:findById()</code>方法并返回对应<code>Employee</code>对象，从而高效的生成一个员工流。</p>
<p>我们可以看到<code>collect()</code>方法是如何在前一个例子中工作的。当我们完成所有处理，就可以用这种方法从流中获取内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenCollectStreamToList_thenGetList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = empList.stream().collect(Collectors.toList());</span><br><span class="line">    assertEquals(empList, employees);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>collect()</code>对流中的数据元素执行可变折叠操作(将元素重新打包到一些数据结构并进行一些额外的逻辑处理，比如将它们连接起来)。</p>
<p>此操作的策略通过Collections接口的实现来提供。在上面的例子中，我们使用<code>toList</code>收集器将流中的元素收集到<code>List</code>实例中。</p>
<p>现在让我们看一下<code>filter()</code>方法。这会产生一个新的流，其中包含通过给定测试（由Predicate指定）的原始流的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFilterEmployees_thenGetFilteredStream</span><span class="params">()</span> &#123;</span><br><span class="line">    Integer[] empIds = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    List&lt;Employee&gt; employees = Stream.of(empIds)</span><br><span class="line">      .map(employeeRepository::findById)</span><br><span class="line">      .filter(e -&gt; e != <span class="literal">null</span>)</span><br><span class="line">      .filter(e -&gt; e.getSalary() &gt; <span class="number">200000</span>)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">    assertEquals(Arrays.asList(arrayOfEmps[<span class="number">2</span>]), employees);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们先筛选掉值为null的不合法员工号，然后再使用了一个过滤器筛选出工资超过一定阈值的员工。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFindFirst_thenGetFirstEmployeeInStream</span><span class="params">()</span> &#123;</span><br><span class="line">    Integer[] empIds = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> Stream.of(empIds)</span><br><span class="line">      .map(employeeRepository::findById)</span><br><span class="line">      .filter(e -&gt; e != <span class="literal">null</span>)</span><br><span class="line">      .filter(e -&gt; e.getSalary() &gt; <span class="number">100000</span>)</span><br><span class="line">      .findFirst()</span><br><span class="line">      .orElse(<span class="literal">null</span>);</span><br><span class="line">    assertEquals(employee.getSalary(), <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">200000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会返回薪水大于10000的第一个员工，如果没有薪水大于10000的员工，则返回null。</p>
<p>我们已经看到了如何使用<code>collect()</code>从数据流中获取数据。如果我们需要从流中获取数组，我们可以简单地使用<code>toArray()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenStreamToArray_thenGetArray</span><span class="params">()</span> &#123;</span><br><span class="line">    Employee[] employees = empList.stream().toArray(Employee[]::<span class="keyword">new</span>);</span><br><span class="line">    assertThat(empList.toArray(), equalTo(employees));</span><br><span class="line">&#125;             </span><br></pre></td></tr></table></figure>
<p><code>Employee[]::new</code>会新建一个空的Employee数组 - 它会用流中的元素填充。</p>
<p>流可以容纳复杂的数据结构，如<code>Stream&lt;List&lt;String&gt;&gt;</code>。在这样的场景下，我们可以使用<code>flatMap()</code>来扁平化数据结构，简化后序的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFlatMapEmployeeNames_thenGetNameStream</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; namesNested = Arrays.asList( </span><br><span class="line">      Arrays.asList(<span class="string">&quot;Jeff&quot;</span>, <span class="string">&quot;Bezos&quot;</span>), </span><br><span class="line">      Arrays.asList(<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;Gates&quot;</span>), </span><br><span class="line">      Arrays.asList(<span class="string">&quot;Mark&quot;</span>, <span class="string">&quot;Zuckerberg&quot;</span>));</span><br><span class="line">    List&lt;String&gt; namesFlatStream = namesNested.stream()</span><br><span class="line">      .flatMap(Collection::stream)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">    assertEquals(namesFlatStream.size(), namesNested.size() * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在前面看到了<code>forEach()</code>的使用，它是一个终结操作。但是，有时我们需要在执行任何终结操作之前对流的每个元素执行多个操作。</p>
<p><code>peek()</code>方法在这种场景下很实用。简单来说，它会在流的每个元素上执行特定的操作，并返回一个新的流。**<code>peek()</code>是一个中间操作**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenIncrementSalaryUsingPeek_thenApplyNewSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    Employee[] arrayOfEmps = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;Jeff Bezos&quot;</span>, <span class="number">100000.0</span>), </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;Bill Gates&quot;</span>, <span class="number">200000.0</span>), </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;Mark Zuckerberg&quot;</span>, <span class="number">300000.0</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Employee&gt; empList = Arrays.asList(arrayOfEmps);</span><br><span class="line">    empList.stream()</span><br><span class="line">      .peek(e -&gt; e.salaryIncrement(<span class="number">10.0</span>))</span><br><span class="line">      .peek(System.out::println)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">    assertThat(empList, contains(</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">110000.0</span>)),</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">220000.0</span>)),</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">330000.0</span>))</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法类型和管道"><a href="#方法类型和管道" class="headerlink" title="方法类型和管道"></a>方法类型和管道</h2><p>我们之前讨论时提出，流操作可以分为中间操作和终结操作。</p>
<p>中间操作如<code>filter()</code>会返回一个新的流，并且可以在该流之上进行后续操作。终结操作如<code>forEach()</code>，将流标记为已经使用，在这之后该流就不可以被使用了。</p>
<p>一个流管道由一个流源组成，然后是零个或多个中间操作，以及一个终端操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenStreamCount_thenGetElementCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">empCount</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .filter(e -&gt; e.getSalary() &gt; <span class="number">200000</span>)</span><br><span class="line">      .count();</span><br><span class="line">    assertEquals(empCount, <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些操作被定义为<strong>短路操作</strong>，短路操作允许在无尽流上的计算可以在有限时间内完成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenLimitInfiniteStream_thenGetFiniteElements</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Integer&gt; infiniteStream = Stream.iterate(<span class="number">2</span>, i -&gt; i * <span class="number">2</span>);</span><br><span class="line">    List&lt;Integer&gt; collect = infiniteStream</span><br><span class="line">      .skip(<span class="number">3</span>)</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">    assertEquals(collect, Arrays.asList(<span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会在后面继续讨论无尽流。</p>
<h2 id="惰性计算"><a href="#惰性计算" class="headerlink" title="惰性计算"></a>惰性计算</h2><p>流的最重要的特征之一是它们允许通过惰性计算进行显著的优化。只有在启动终结操作的时候才会执行流上的计算。所有的中间操作都是惰性执行的，所以除非在需要得出结果的时候，否则它们不会执行。</p>
<p>比如，我们之前看到的<code>findFirst()</code>例子。这里执行了多少次<code>map()</code>操作？4次，因为输入数组包含4个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFindFirst_thenGetFirstEmployeeInStream</span><span class="params">()</span> &#123;</span><br><span class="line">    Integer[] empIds = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> Stream.of(empIds)</span><br><span class="line">      .map(employeeRepository::findById)</span><br><span class="line">      .filter(e -&gt; e != <span class="literal">null</span>)</span><br><span class="line">      .filter(e -&gt; e.getSalary() &gt; <span class="number">100000</span>)</span><br><span class="line">      .findFirst()</span><br><span class="line">      .orElse(<span class="literal">null</span>);</span><br><span class="line">    assertEquals(employee.getSalary(), <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">200000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stream执行了一个map操作和两个filter操作。</p>
<p>它首先在id 1上执行所有操作。由于id 1的工资不大于100000，处理转移到下一个元素。</p>
<p>Id 2满足两个过滤器谓词，因此流将执行终结操作<code>findFirst()</code>并返回结果。</p>
<p>在Id 3 和Id 4上不会执行任何操作。</p>
<p>处理数据流时，可以避免在不必要时检查所有数据。当输入流是无限的并且非常大时，这种行为变得更加重要。</p>
<h2 id="基于比较的流操作"><a href="#基于比较的流操作" class="headerlink" title="基于比较的流操作"></a>基于比较的流操作</h2><p>让我们从<code>sorted()</code>方法开始。它会根据我们传入的比较器对流元素进行排序。</p>
<p>例如，我们可以根据名字对员工进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenSortStream_thenGetSortedStream</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = empList.stream()</span><br><span class="line">      .sorted((e1, e2) -&gt; e1.getName().compareTo(e2.getName()))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">    assertEquals(employees.get(<span class="number">0</span>).getName(), <span class="string">&quot;Bill Gates&quot;</span>);</span><br><span class="line">    assertEquals(employees.get(<span class="number">1</span>).getName(), <span class="string">&quot;Jeff Bezos&quot;</span>);</span><br><span class="line">    assertEquals(employees.get(<span class="number">2</span>).getName(), <span class="string">&quot;Mark Zuckerberg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意在<code>sorted()</code>方法中不会进行短路操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFindMin_thenGetMinElementFromStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">firstEmp</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .min((e1, e2) -&gt; e1.getId() - e2.getId())</span><br><span class="line">      .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br><span class="line">    assertEquals(firstEmp.getId(), <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以通过使用<code>Comparator.comparing()</code>方法免去定义比较逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFindMax_thenGetMaxElementFromStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">maxSalEmp</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .max(Comparator.comparing(Employee::getSalary))</span><br><span class="line">      .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br><span class="line">    assertEquals(maxSalEmp.getSalary(), <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">300000.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>distinct()</code>不接受任何参数并返回流中的不同元素，从而消除重复。它使用元素的<code>equals()</code>方法来决定两个元素是否相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenApplyDistinct_thenRemoveDuplicatesFromStream</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; intList = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    List&lt;Integer&gt; distinctIntList = intList.stream().distinct().collect(Collectors.toList());</span><br><span class="line">    assertEquals(distinctIntList, Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="allMatch-anyMatch和noneMatch"><a href="#allMatch-anyMatch和noneMatch" class="headerlink" title="allMatch, anyMatch和noneMatch"></a>allMatch, anyMatch和noneMatch</h2><p>这些操作会接收一个<code>Predicate</code>并返回一个boolean值。一旦确定了答案，就执行短路操作并停止处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenApplyMatch_thenReturnBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; intList = Arrays.asList(<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allEven</span> <span class="operator">=</span> intList.stream().allMatch(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">oneEven</span> <span class="operator">=</span> intList.stream().anyMatch(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">noneMultipleOfThree</span> <span class="operator">=</span> intList.stream().noneMatch(i -&gt; i % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">    assertEquals(allEven, <span class="literal">false</span>);</span><br><span class="line">    assertEquals(oneEven, <span class="literal">true</span>);</span><br><span class="line">    assertEquals(noneMultipleOfThree, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allMatch()</code>会检查流中所有元素的谓词是否为真。在它遇到5时无法被2整除，它会立即返回false。</p>
<p><code>anyMatch()</code>会检查流中任何一个元素的谓词是否为真。这里，再次施加短路操作并且在第一个元素之后立即返回true。</p>
<p><code>noneMatch()</code>检查是否没有与谓词匹配的元素。在这里，只要遇到可被3整除的6就返回false。</p>
<h2 id="特定类型的流"><a href="#特定类型的流" class="headerlink" title="特定类型的流"></a>特定类型的流</h2><p>目前为止，我们讨论的都是对象引用流。但是还有<code>IntStream, LongStream, 和 DoubleStream</code>分别对应Int，Long和Double基础数据类型的流。当需要处理大量的数字类型值时，使用它们会非常方便。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个IntStream最常用的方法是在一个现有流上调用<code>mapToInt()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFindMaxOnIntStream_thenGetMaxInteger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">latestEmpId</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .mapToInt(Employee::getId)</span><br><span class="line">      .max()</span><br><span class="line">      .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br><span class="line">    assertEquals(latestEmpId, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先生成了一个<code>empList</code>的流然后再在其上通过在<code>mapToInt</code>中调用<code>Employee::getId</code>方法来获得一个IntStream。最后我们调用<code>max()</code>获得最大值。</p>
<p>我们还可以使用<code>IntStream.of()</code>生成IntStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>或者是<code>IntStream.range()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>它会生成一个包含10-19之间所有整数的IntStream。<br>这里有一个重要的区别需要注意一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>该方法生成的是一个<code>Stream&lt;Integer&gt;</code>对象而不是<code>IntStream</code>。<br>类似的，使用<code>map()</code>而不是<code>mapToInt()</code>将会生成<code>Stream&lt;Integer&gt;</code>而不是<code>IntStream</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">empList.stream().map(Employee::getId);</span><br></pre></td></tr></table></figure>

<h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><p>特定类型的流相比于标准的流提供了额外的操作。比如<code>sum(), average(), range()</code>等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenApplySumOnIntStream_thenGetSum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">avgSal</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .mapToDouble(Employee::getSalary)</span><br><span class="line">      .average()</span><br><span class="line">      .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br><span class="line">    assertEquals(avgSal, <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">200000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reduction操作"><a href="#Reduction操作" class="headerlink" title="Reduction操作"></a>Reduction操作</h2><p><strong>Reduction操作（也称为fold）获得一系列输入元素，并通过重复执行组合操作将它们组合为单个汇总结果。</strong>我们已经看到过几个Reduction操作如<code>findFirst(), min()和max()</code>。</p>
<p>让我们看一看通俗意义上的<code>reduce()</code>的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span><br></pre></td></tr></table></figure>
<p>identity代表起始值而accumulator代表一个二元操作符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenApplyReduceOnStream_thenGetValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">sumSal</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .map(Employee::getSalary)</span><br><span class="line">      .reduce(<span class="number">0.0</span>, Double::sum);</span><br><span class="line">    assertEquals(sumSal, <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">600000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将起始值设置为0.0并且对流上的元素重复的执行<code>Double::sum()</code>。通过在Stream中使用<code>reduce</code>我们有效的实现了DoubleStream的sum方法。</p>
<h2 id="高级collect"><a href="#高级collect" class="headerlink" title="高级collect"></a>高级collect</h2><p>我们已经看过如何使用<code>Collectors.toList()</code>从流中获取list。让我们再看几个从流中获取数据的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenCollectByJoining_thenGetJoinedString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">empNames</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .map(Employee::getName)</span><br><span class="line">      .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">      .toString();</span><br><span class="line">    assertEquals(empNames, <span class="string">&quot;Jeff Bezos, Bill Gates, Mark Zuckerberg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用<code>toSet</code>方法从流中获取Set：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenCollectBySet_thenGetSet</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; empNames = empList.stream()</span><br><span class="line">            .map(Employee::getName)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    assertEquals(empNames.size(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toCollection"><a href="#toCollection" class="headerlink" title="toCollection"></a>toCollection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenToVectorCollection_thenGetVector</span><span class="params">()</span> &#123;</span><br><span class="line">    Vector&lt;String&gt; empNames = empList.stream()</span><br><span class="line">            .map(Employee::getName)</span><br><span class="line">            .collect(Collectors.toCollection(Vector::<span class="keyword">new</span>));</span><br><span class="line">    assertEquals(empNames.size(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里内部创建了一个新的空集合，并对流中的每个元素调用了<code>add()</code>方法。</p>
<h2 id="summarizingDouble"><a href="#summarizingDouble" class="headerlink" title="summarizingDouble"></a>summarizingDouble</h2><p><code>summarizingDouble</code>是另一个有趣的收集器。它对每个输入元素执行一个double-producing映射函数并返回一个包含结果值统计信息的特殊类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenApplySummarizing_thenGetBasicStats</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DoubleSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line">    assertEquals(stats.getCount(), <span class="number">3</span>);</span><br><span class="line">    assertEquals(stats.getSum(), <span class="number">600000.0</span>, <span class="number">0</span>);</span><br><span class="line">    assertEquals(stats.getMin(), <span class="number">100000.0</span>, <span class="number">0</span>);</span><br><span class="line">    assertEquals(stats.getMax(), <span class="number">300000.0</span>, <span class="number">0</span>);</span><br><span class="line">    assertEquals(stats.getAverage(), <span class="number">200000.0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们是如何分析每位员工的工资并获取有关该数据的统计信息 - 如最小值，最大值，平均值等。</p>
<p><code>summaryStatistics()</code>可以在使用特定流的时候用来生成类似的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenApplySummaryStatistics_thenGetBasicStats</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DoubleSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> empList.stream()</span><br><span class="line">      .mapToDouble(Employee::getSalary)</span><br><span class="line">      .summaryStatistics();</span><br><span class="line">    assertEquals(stats.getCount(), <span class="number">3</span>);</span><br><span class="line">    assertEquals(stats.getSum(), <span class="number">600000.0</span>, <span class="number">0</span>);</span><br><span class="line">    assertEquals(stats.getMin(), <span class="number">100000.0</span>, <span class="number">0</span>);</span><br><span class="line">    assertEquals(stats.getMax(), <span class="number">300000.0</span>, <span class="number">0</span>);</span><br><span class="line">    assertEquals(stats.getAverage(), <span class="number">200000.0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="partitioningBy"><a href="#partitioningBy" class="headerlink" title="partitioningBy"></a>partitioningBy</h2><p>我们可以根据元素是否满足某个条例将一个流分解为两个。</p>
<p>让我们将一个数值数组分成奇数数组和偶数数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenStreamPartition_thenGetMap</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; intList = Arrays.asList(<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    Map&lt;Boolean, List&lt;Integer&gt;&gt; isEven = intList.stream().collect(</span><br><span class="line">      Collectors.partitioningBy(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    assertEquals(isEven.get(<span class="literal">true</span>).size(), <span class="number">4</span>);</span><br><span class="line">    assertEquals(isEven.get(<span class="literal">false</span>).size(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，流被分解并存入Map中，并使用true和false键代表偶数数组和奇数数组。</p>
<h2 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h2><p><code>groupingBy()</code>提供高级分解。它将我们的流分解为两个或多个子流。</p>
<p>它接收一个分类方法作为参数。这个分类方法会作用于流中的每一个元素。</p>
<p>分类方法返回的值会作为Map的键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenStreamGroupingBy_thenGetMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;Character, List&lt;Employee&gt;&gt; groupByAlphabet = empList.stream().collect(</span><br><span class="line">      Collectors.groupingBy(e -&gt; <span class="keyword">new</span> <span class="title class_">Character</span>(e.getName().charAt(<span class="number">0</span>))));</span><br><span class="line">    assertEquals(groupByAlphabet.get(<span class="string">&#x27;B&#x27;</span>).get(<span class="number">0</span>).getName(), <span class="string">&quot;Bill Gates&quot;</span>);</span><br><span class="line">    assertEquals(groupByAlphabet.get(<span class="string">&#x27;J&#x27;</span>).get(<span class="number">0</span>).getName(), <span class="string">&quot;Jeff Bezos&quot;</span>);</span><br><span class="line">    assertEquals(groupByAlphabet.get(<span class="string">&#x27;M&#x27;</span>).get(<span class="number">0</span>).getName(), <span class="string">&quot;Mark Zuckerberg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个简单的例子中，我们根据员工的首字母进行分组。<code>groupingBy()</code>使用Map对流中的数据进行分组。但是，有时候我们可能需要将元素分组为另一种类型。我们可以使用<code>mapping()</code>，它实际上可以使收集器适应不同的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenStreamMapping_thenGetMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;Character, List&lt;Integer&gt;&gt; idGroupedByAlphabet = empList.stream().collect(</span><br><span class="line">      Collectors.groupingBy(e -&gt; <span class="keyword">new</span> <span class="title class_">Character</span>(e.getName().charAt(<span class="number">0</span>)),</span><br><span class="line">        Collectors.mapping(Employee::getId, Collectors.toList())));</span><br><span class="line">    assertEquals(idGroupedByAlphabet.get(<span class="string">&#x27;B&#x27;</span>).get(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">    assertEquals(idGroupedByAlphabet.get(<span class="string">&#x27;J&#x27;</span>).get(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">    assertEquals(idGroupedByAlphabet.get(<span class="string">&#x27;M&#x27;</span>).get(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>mapping()</code>使用<code>getId()</code>映射函数将流元素Employee映射到员工id - 这是一个Integer。这些ID仍然根据员工名字的首字母进行分组。<br><code>reducing()</code>类似于<code>reduce()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenStreamReducing_thenGetValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">percentage</span> <span class="operator">=</span> <span class="number">10.0</span>;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">salIncrOverhead</span> <span class="operator">=</span> empList.stream().collect(Collectors.reducing(</span><br><span class="line">        <span class="number">0.0</span>, e -&gt; e.getSalary() * percentage / <span class="number">100</span>, (s1, s2) -&gt; s1 + s2));</span><br><span class="line">    assertEquals(salIncrOverhead, <span class="number">60000.0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reducing</code> + <code>groupingBy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenStreamGroupingAndReducing_thenGetMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Comparator&lt;Employee&gt; byNameLength = Comparator.comparing(Employee::getName);</span><br><span class="line">    Map&lt;Character, Optional&lt;Employee&gt;&gt; longestNameByAlphabet = empList.stream().collect(</span><br><span class="line">      Collectors.groupingBy(e -&gt; <span class="keyword">new</span> <span class="title class_">Character</span>(e.getName().charAt(<span class="number">0</span>)),</span><br><span class="line">        Collectors.reducing(BinaryOperator.maxBy(byNameLength))));</span><br><span class="line">    assertEquals(longestNameByAlphabet.get(<span class="string">&#x27;B&#x27;</span>).get().getName(), <span class="string">&quot;Bill Gates&quot;</span>);</span><br><span class="line">    assertEquals(longestNameByAlphabet.get(<span class="string">&#x27;J&#x27;</span>).get().getName(), <span class="string">&quot;Jeff Bezos&quot;</span>);</span><br><span class="line">    assertEquals(longestNameByAlphabet.get(<span class="string">&#x27;M&#x27;</span>).get().getName(), <span class="string">&quot;Mark Zuckerberg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先根据员工的首字母将其分组，然后在各个组里，我们找到名字最长的员工。</p>
<h2 id="Parallel-Streams"><a href="#Parallel-Streams" class="headerlink" title="Parallel Streams"></a>Parallel Streams</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenParallelStream_thenPerformOperationsInParallel</span><span class="params">()</span> &#123;</span><br><span class="line">    Employee[] arrayOfEmps = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;Jeff Bezos&quot;</span>, <span class="number">100000.0</span>), </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;Bill Gates&quot;</span>, <span class="number">200000.0</span>), </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;Mark Zuckerberg&quot;</span>, <span class="number">300000.0</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Employee&gt; empList = Arrays.asList(arrayOfEmps);</span><br><span class="line">    empList.stream().parallel().forEach(e -&gt; e.salaryIncrement(<span class="number">10.0</span>));</span><br><span class="line">    assertThat(empList, contains(</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">110000.0</span>)),</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">220000.0</span>)),</span><br><span class="line">      hasProperty(<span class="string">&quot;salary&quot;</span>, equalTo(<span class="number">330000.0</span>))</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里涉及到多线程，所以我们需要注意一下几点：</p>
<ul>
<li>确保代码是线程安全的。特别要注意并行操作可能会的修改的共享数据。</li>
<li>如果执行操作的顺序或输出流中返回的顺序很重要，我们不应该使用并行流。例如<code>findFirst()</code>等操作可能在并行数据流中产生不同的结果。</li>
<li>确保并行执行是值得的。</li>
</ul>
<h2 id="Infinite-Streams"><a href="#Infinite-Streams" class="headerlink" title="Infinite Streams"></a>Infinite Streams</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenGenerateStream_thenGetInfiniteStream</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream.generate(Math::random)</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们给<code>generate()</code>方法提供了<code>Supplier</code>，当需要新元素时就会调用这个方法。<br>我们需要提供一个终止进程的条件。通常使用的一种方法是<code>limit()</code>。在上面的例子中，我们将元素的数量限制为5，并在它们生成时候打印它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenIterateStream_thenGetInfiniteStream</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Integer&gt; evenNumStream = Stream.iterate(<span class="number">2</span>, i -&gt; i * <span class="number">2</span>);</span><br><span class="line">    List&lt;Integer&gt; collect = evenNumStream</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">    assertEquals(collect, Arrays.asList(<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>iterate()</code>有两个参数：一个初始值，称为种子值，和一个使用前一个值来生成下一个值的函数。该方法是有状态的，因此不适合并行运行。</p>
<blockquote>
<p>原文链接: <a href="https://dzone.com/articles/a-guide-to-streams-in-java-8-in-depth-tutorial-wit">https://dzone.com/articles/a-guide-to-streams-in-java-8-in-depth-tutorial-wit</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"># 翻译</a>
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/02/05/CAS/" rel="prev" title="猫头鹰的深夜翻译：Java中的CAS(Compare And Swap)">
                  <i class="fa fa-angle-left"></i> 猫头鹰的深夜翻译：Java中的CAS(Compare And Swap)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/02/05/%E7%8C%AB%E5%A4%B4%E9%B9%B0%E7%9A%84%E6%B7%B1%E5%A4%9C%E7%BF%BB%E8%AF%91%EF%BC%9A%E5%9C%A8JVM%E4%B8%8A%E6%A0%B9%E6%8D%AE%E5%90%88%E7%BA%A6%E7%BC%96%E7%A8%8B/" rel="next" title="猫头鹰的深夜翻译：在JVM上根据合约编程">
                  猫头鹰的深夜翻译：在JVM上根据合约编程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Rale Dong</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
